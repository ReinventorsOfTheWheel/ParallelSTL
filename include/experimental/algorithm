#ifndef _EXPERIMENTAL_N3554_ALGORITHM
#define _EXPERIMENTAL_N3554_ALGORITHM

#include <utility> // std::pair
#include <iterator>

#include <experimental/execution_policy>

namespace std { 
namespace experimental {
namespace parallel {
inline namespace v1 {

  // non-modifying sequence operations:
  template<class ExecutionPolicy,
           class InputIterator, class Predicate>
    bool all_of(ExecutionPolicy &&exec,
                InputIterator first, InputIterator last, Predicate pred)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");
    return exec.all_of(first, last, pred);
  }

  template<class ExecutionPolicy,
           class InputIterator, class Predicate>
    bool any_of(ExecutionPolicy &&exec,
                InputIterator first, InputIterator last, Predicate pred)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");
    return exec.any_of(first, last, pred);
  }
  template<class ExecutionPolicy,
           class InputIterator, class Predicate>
    bool none_of(ExecutionPolicy &&exec,
                 InputIterator first, InputIterator last, Predicate pred)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "'exec' is not a valid execution policy");
    return exec.none_of(first, last, pred);
  }

  template<class ExecutionPolicy,
           class InputIterator, class Function> // requires CopyConstructible<Function>
    void for_each(ExecutionPolicy &&exec,
                  InputIterator first, InputIterator last,
                  Function f)
  {
    static_assert(std::is_copy_constructible<Function>::value,
                  "Function must be copy constructible");
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");
    exec.for_each(first, last, f);
  }

  template<class InputIterator, class Size, class Function> // requires MoveConstructible<Function>
    InputIterator for_each_n(InputIterator first, Size n,
                             Function f) 
  {
    static_assert(std::is_move_constructible<Function>::value,
                  "Function must be move constructible");
    if(n < 0)
      return first;
    auto end = first;
    advance(end, n);
    for_each(first, end, f);
    return end;
  }

  template<class ExecutionPolicy,
           class InputIterator, class Size, class Function> // requires MoveConstructible<Function>
    InputIterator for_each_n(ExecutionPolicy &&exec,
                             InputIterator first, Size n,
                             Function f) 
  {
    static_assert(std::is_move_constructible<Function>::value,
                  "Function must be move constructible");
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");
    return exec.for_each_n(first, n, f);
  }

  template<class ExecutionPolicy,
           class InputIterator, class T>
    InputIterator find(ExecutionPolicy &&exec,
                       InputIterator first, InputIterator last,
                       const T& value)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.find(first, last, value);
  }
  template<class ExecutionPolicy,
           class InputIterator, class Predicate>
    InputIterator find_if(ExecutionPolicy &&exec,
                          InputIterator first, InputIterator last,
                          Predicate pred)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.find_if(first, last, pred);
  }
  template<class ExecutionPolicy,
           class InputIterator, class Predicate>
    InputIterator find_if_not(ExecutionPolicy &&exec,
                              InputIterator first, InputIterator last,
                              Predicate pred)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.find_if_not(first, last, pred);
  }

  template<class ExecutionPolicy,
           class ForwardIterator1, class ForwardIterator2>
    ForwardIterator1
      find_end(ExecutionPolicy &exec,
               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.find_end(first1, last1, first2, last2);
  }
  template<class ExecutionPolicy,
           class ForwardIterator1, class ForwardIterator2,
           class BinaryPredicate>
    ForwardIterator1
      find_end(ExecutionPolicy &&exec,
               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2,
               BinaryPredicate pred)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.find_end(first1, last1, first2, last2, pred);
  }

  template<class ExecutionPolicy,
           class InputIterator, class ForwardIterator>
    InputIterator
      find_first_of(ExecutionPolicy &&exec,
                    InputIterator first1, InputIterator last1,
                    ForwardIterator first2, ForwardIterator last2)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.find_first_of(first1, last1, first2, last2);
  }
  template<class ExecutionPolicy,
           class InputIterator, class ForwardIterator,
           class BinaryPredicate>
    InputIterator
      find_first_of(ExecutionPolicy &&exec,
                    InputIterator first1, InputIterator last1,
                    ForwardIterator first2, ForwardIterator last2,
                    BinaryPredicate pred)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.find_first_of(first1, last1, first2, last2, pred);
  }

  template<class ExecutionPolicy,
           class ForwardIterator>
    ForwardIterator adjacent_find(ExecutionPolicy &&exec, ForwardIterator first, ForwardIterator last)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.adjacent_find(first, last);
  }
  template<class ExecutionPolicy,
           class ForwardIterator, class BinaryPredicate>
    ForwardIterator adjacent_find(ExecutionPolicy &&exec, ForwardIterator first, ForwardIterator last,
                                  BinaryPredicate pred)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.adjacent_find(first, last, pred);
  }

  template<class ExecutionPolicy,
           class InputIterator, class EqualityComparable>
    typename iterator_traits<InputIterator>::difference_type
      count(ExecutionPolicy &&exec,
            InputIterator first, InputIterator last, const EqualityComparable &value)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.count(first, last, value);
  }
  template<class ExecutionPolicy,
           class InputIterator, class Predicate>
    typename iterator_traits<InputIterator>::difference_type
      count_if(ExecutionPolicy &&exec,
               InputIterator first, InputIterator last, Predicate pred)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.count_if(first, last, pred);
  }

  template<class ExecutionPolicy,
           class InputIterator1, class InputIterator2>
    pair<InputIterator1,InputIterator2>
      mismatch(ExecutionPolicy &&exec,
               InputIterator1 first1, InputIterator1 last1, 
               InputIterator2 first2)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.mismatch(first1, last1, first2);
  }
  template<class ExecutionPolicy,
           class InputIterator1, class InputIterator2, class BinaryPredicate>
    pair<InputIterator1,InputIterator2>
      mismatch(ExecutionPolicy &&exec,
               InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2, BinaryPredicate pred)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.mismatch(first1, last1, first2, pred);
  }

  template<class ExecutionPolicy,
           class InputIterator1, class InputIterator2>
    bool equal(ExecutionPolicy &&exec,
               InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.equal(first1, last1, first2);
  }
  template<class ExecutionPolicy,
           class InputIterator1, class InputIterator2, class BinaryPredicate>
    bool equal(ExecutionPolicy &&exec,
               InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2, BinaryPredicate pred)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.equal(first1, last1, first2, pred);
  }

  template<class ExecutionPolicy,
           class ForwardIterator1, class ForwardIterator2>
    ForwardIterator1 search(ExecutionPolicy &&exec,
                            ForwardIterator1 first1, ForwardIterator1 last1,
                            ForwardIterator2 first2, ForwardIterator2 last2)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.search(first1, last1, first2, last2);
  }
  template<class ExecutionPolicy,
           class ForwardIterator1, class ForwardIterator2,
           class BinaryPredicate>
    ForwardIterator1 search(ExecutionPolicy &&exec,
                            ForwardIterator1 first1, ForwardIterator1 last1,
                            ForwardIterator2 first2, ForwardIterator2 last2,
                            BinaryPredicate pred)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.search(first1, last1, first2, last2, pred);
  }
  template<class ExecutionPolicy,
           class ForwardIterator, class Size, class T>
    ForwardIterator search_n(ExecutionPolicy &&exec,
                             ForwardIterator first, ForwardIterator last, Size count,
                             const T& value)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.search_n(first, last, count, value);
  }
  template<class ExecutionPolicy,
           class ForwardIterator, class Size, class T, class BinaryPredicate>
    ForwardIterator search_n(ExecutionPolicy &&exec,
                             ForwardIterator first, ForwardIterator last, Size count,
                             const T& value, BinaryPredicate pred)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.search_n(first, last, count, value, pred);
  }

  // modifying sequence operations:
  // copy:
  template<class ExecutionPolicy,
           class InputIterator, class OutputIterator>
    OutputIterator copy(ExecutionPolicy &&exec,
                        InputIterator first, InputIterator last,
                        OutputIterator result)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.copy(first, last, result);
  }

  template<class ExecutionPolicy,
           class InputIterator, class Size, class OutputIterator>
    OutputIterator copy_n(ExecutionPolicy &&exec,
                          InputIterator first, Size n,
                          OutputIterator result)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.copy_n(first, n, result);
  }

  template<class ExecutionPolicy,
           class InputIterator, class OutputIterator, class Predicate>
    OutputIterator
      copy_if(ExecutionPolicy &&exec,
              InputIterator first, InputIterator last,
              OutputIterator result, Predicate pred)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.copy_if(first, last, result, pred);
  }

  // move:
  template<class ExecutionPolicy,
           class InputIterator, class OutputIterator>
    OutputIterator
      move(ExecutionPolicy &&exec,
           InputIterator first, InputIterator last,
           OutputIterator result)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.move(first, last, result); 
  }

  // swap:
  template<class ExecutionPolicy,
           class ForwardIterator1, class ForwardIterator2>
    ForwardIterator2
      swap_ranges(ExecutionPolicy &&exec,
                  ForwardIterator1 first1, ForwardIterator1 last1,
                  ForwardIterator2 first2)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.swap_ranges(first1, last1, first2);
  }

  template<class ExecutionPolicy,
           class InputIterator, class OutputIterator,
           class UnaryOperation>
    OutputIterator transform(ExecutionPolicy &&exec,
                             InputIterator first, InputIterator last,
                             OutputIterator result, UnaryOperation op)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.transform(first, last, result, op);
  }
  template<class ExecutionPolicy,
           class InputIterator1, class InputIterator2, class OutputIterator,
           class BinaryOperation>
    OutputIterator
      transform(ExecutionPolicy &&exec,
                InputIterator1 first1, InputIterator1 last1,
                InputIterator2 first2, OutputIterator result,
                BinaryOperation binary_op)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.transform(first1, last1, first2, result, binary_op);
  }

  template<class ExecutionPolicy,
           class ForwardIterator, class T>
    void replace(ExecutionPolicy &&exec,
                 ForwardIterator first, ForwardIterator last,
                 const T& old_value, const T& new_value)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    exec.replace(first, last, old_value, new_value);
  }
  template<class ExecutionPolicy,
           class ForwardIterator, class Predicate, class T>
    void replace_if(ExecutionPolicy &&exec,
                    ForwardIterator first, ForwardIterator last,
                    Predicate pred, const T& new_value)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    exec.replace_if(first, last, pred, new_value);
  }
  template<class ExecutionPolicy,
           class InputIterator, class OutputIterator, class T>
    OutputIterator
      replace_copy(ExecutionPolicy &&exec,
                   InputIterator first, InputIterator last,
                   OutputIterator result,
                   const T& old_value, const T& new_value)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.replace_copy(first, last, result, old_value, new_value);
  }
  template<class ExecutionPolicy,
           class InputIterator, class OutputIterator, class Predicate, class T>
    OutputIterator
      replace_copy_if(ExecutionPolicy &&exec,
                      InputIterator first, InputIterator last,
                      OutputIterator result,
                      Predicate pred, const T& new_value)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.replace_copy_if(first, last, result, pred, new_value);
  }

  template<class ExecutionPolicy,
           class ForwardIterator, class T>
    void fill(ExecutionPolicy &&exec,
              ForwardIterator first, ForwardIterator last, const T& value)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    exec.fill(first, last, value);
  }
  template<class ExecutionPolicy,
           class OutputIterator, class Size, class T>
    OutputIterator fill_n(ExecutionPolicy &&exec,
                OutputIterator first, Size n, const T& value)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.fill_n(first, n, value);
  }

  template<class ExecutionPolicy,
           class ForwardIterator, class Generator>
    void generate(ExecutionPolicy &&exec,
                  ForwardIterator first, ForwardIterator last, Generator gen)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    exec.generate(first, last, gen);
  }
  template<class ExecutionPolicy,
           class OutputIterator, class Size, class Generator>
    OutputIterator generate_n(ExecutionPolicy &&exec,
                              OutputIterator first, Size n, Generator gen)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.generate_n(first, n, gen);
  }

  template<class ExecutionPolicy,
           class ForwardIterator, class T>
    ForwardIterator remove(ExecutionPolicy &&exec,
                           ForwardIterator first, ForwardIterator last, const T& value)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.remove(first, last, value);
  }
  template<class ExecutionPolicy,
           class ForwardIterator, class Predicate>
    ForwardIterator remove_if(ExecutionPolicy &&exec,
                              ForwardIterator first, ForwardIterator last, Predicate pred)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.remove_if(first, last, pred);
  }
  template<class ExecutionPolicy,
           class InputIterator, class OutputIterator, class T>
    OutputIterator
      remove_copy(ExecutionPolicy &&exec,
                  InputIterator first, InputIterator last,
                  OutputIterator result, const T& value)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.remove_copy(first, last, result, value);
  }
  template<class ExecutionPolicy,
           class InputIterator, class OutputIterator, class Predicate>
    OutputIterator
      remove_copy_if(ExecutionPolicy &&exec,
                     InputIterator first, InputIterator last,
                     OutputIterator result, Predicate pred)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.remove_copy_if(first, last, result, pred);
  }

  template<class ExecutionPolicy,
           class ForwardIterator>
    ForwardIterator unique(ExecutionPolicy &&exec,
                           ForwardIterator first, ForwardIterator last)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.unique(first, last);
  }
  template<class ExecutionPolicy,
           class ForwardIterator, typename BinaryPredicate>
    ForwardIterator unique(ExecutionPolicy &&exec,
                           ForwardIterator first, ForwardIterator last,
                           BinaryPredicate pred)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.unique(first, last, pred);
  }

  template<class ExecutionPolicy,
           class InputIterator, class OutputIterator>
    OutputIterator
      unique_copy(ExecutionPolicy &&exec,
                  InputIterator first, InputIterator last,
                  OutputIterator result)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.unique_copy(first, last, result);
  }
  template<class ExecutionPolicy,
           class InputIterator, class OutputIterator, class BinaryPredicate>
    OutputIterator
      unique_copy(ExecutionPolicy &&exec,
                  InputIterator first, InputIterator last,
                  OutputIterator result, BinaryPredicate pred)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.unique_copy(first, last, result, pred);
  }

  template<class ExecutionPolicy,
           class BidirectionalIterator>
    void reverse(ExecutionPolicy &&exec,
                 BidirectionalIterator first, BidirectionalIterator last)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    exec.reverse(first, last);
  }

  template<class ExecutionPolicy,
           class BidirectionalIterator, class OutputIterator>
    OutputIterator
      reverse_copy(ExecutionPolicy &&exec,
                   BidirectionalIterator first,
                   BidirectionalIterator last, OutputIterator result)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.reverse_copy(first, last, result);
  }

  template<class ExecutionPolicy,
           class ForwardIterator>
    ForwardIterator rotate(ExecutionPolicy &&exec,
                           ForwardIterator first, ForwardIterator middle,
                           ForwardIterator last)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.rotate(first, middle, last);
  }
  template<class ExecutionPolicy,
           class ForwardIterator, class OutputIterator>
    OutputIterator
      rotate_copy(ExecutionPolicy &&exec,
                  ForwardIterator first, ForwardIterator middle,
                  ForwardIterator last, OutputIterator result)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.rotate_copy(first, middle, last, result);
  }

  // partitions:
  template<class ExecutionPolicy,
           class InputIterator, class Predicate>
    bool is_partitioned(ExecutionPolicy &&exec,
                        InputIterator first, InputIterator last, Predicate pred)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.is_partitioned(first, last, pred);
  }
  template<class ExecutionPolicy,
           class ForwardIterator, class Predicate>
    ForwardIterator
      partition(ExecutionPolicy &&exec,
                ForwardIterator first,
                ForwardIterator last, Predicate pred)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.partition(first, last, pred);
  }
  template<class ExecutionPolicy,
           class BidirectionalIterator, class Predicate>
    BidirectionalIterator
      stable_partition(ExecutionPolicy &&exec,
                       BidirectionalIterator first,
                       BidirectionalIterator last, Predicate pred)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.stable_partition(first, last, pred);
  }
  template<class ExecutionPolicy,
           class InputIterator, class OutputIterator1,
           class OutputIterator2, class Predicate>
  pair<OutputIterator1, OutputIterator2>
  partition_copy(ExecutionPolicy &&exec,
                 InputIterator first, InputIterator last,
                 OutputIterator1 out_true, OutputIterator2 out_false,
                 Predicate pred)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.partition_copy(first, last, out_true, out_false, pred);
  }
  template<class ExecutionPolicy,
           class ForwardIterator, class Predicate>
    ForwardIterator partition_point(ExecutionPolicy &&exec,
                                    ForwardIterator first,
                                    ForwardIterator last,
                                    Predicate pred)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.partition_point(first, last, pred);
  }

  // sorting and related operations:
  // sorting:
  template<class ExecutionPolicy,
           class RandomAccessIterator>
    void sort(ExecutionPolicy &&exec,
              RandomAccessIterator first, RandomAccessIterator last)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    exec.sort(first, last);
  }
  template<class ExecutionPolicy,
           class RandomAccessIterator, class Compare>
    void sort(ExecutionPolicy &&exec,
              RandomAccessIterator first, RandomAccessIterator last, Compare comp)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    exec.sort(first, last, comp);
  }

  template<class ExecutionPolicy,
           class RandomAccessIterator>
    void stable_sort(ExecutionPolicy &&exec,
                     RandomAccessIterator first, RandomAccessIterator last)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    exec.stable_sort(first, last);
  }
  template<class ExecutionPolicy,
           class RandomAccessIterator, class Compare>
    void stable_sort(ExecutionPolicy &&exec,
                     RandomAccessIterator first, RandomAccessIterator last,
                     Compare comp)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    exec.stable_sort(first, last, comp);
  }

  template<class ExecutionPolicy,
           class RandomAccessIterator>
    void partial_sort(ExecutionPolicy &&exec,
                      RandomAccessIterator first,
                      RandomAccessIterator middle,
                      RandomAccessIterator last)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    exec.partial_sort(first, middle, last);
  }
  template<class ExecutionPolicy,
           class RandomAccessIterator, class Compare>
    void partial_sort(ExecutionPolicy &&exec,
                      RandomAccessIterator first,
                      RandomAccessIterator middle,
                      RandomAccessIterator last,
                      Compare comp)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    exec.partial_sort(first, middle, last, comp);
  }
  template<class ExecutionPolicy,
           class InputIterator, class RandomAccessIterator>
    RandomAccessIterator
      partial_sort_copy(ExecutionPolicy &&exec,
                        InputIterator first, InputIterator last,
                        RandomAccessIterator result_first,
                        RandomAccessIterator result_last)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.partial_sort_copy(first, last, result_first, result_last);
  }
  template<class ExecutionPolicy,
           class InputIterator, class RandomAccessIterator,
           class Compare>
    RandomAccessIterator
      partial_sort_copy(ExecutionPolicy &&exec,
                        InputIterator first, InputIterator last,
                        RandomAccessIterator result_first,
                        RandomAccessIterator result_last,
                        Compare comp)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.partial_sort_copy(first, last, result_first, result_last, comp);
  }

  template<class ExecutionPolicy,
           class ForwardIterator>
    bool is_sorted(ExecutionPolicy &&exec,
                   ForwardIterator first, ForwardIterator last)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.is_sorted(first, last);
  }
  template<class ExecutionPolicy,
           class ForwardIterator, class Compare>
    bool is_sorted(ExecutionPolicy &&exec,
                   ForwardIterator first, ForwardIterator last,
                   Compare comp)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.is_sorted(first, last, comp);
  }
  template<class ExecutionPolicy,
           class ForwardIterator>
    ForwardIterator is_sorted_until(ExecutionPolicy &&exec,
                                    ForwardIterator first, ForwardIterator last)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.is_sorted_until(first, last);
  }
  template<class ExecutionPolicy,
           class ForwardIterator, class Compare>
    ForwardIterator is_sorted_until(ExecutionPolicy &&exec,
                                    ForwardIterator first, ForwardIterator last,
                                    Compare comp)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.is_sorted_until(first, last, comp);
  }

  template<class ExecutionPolicy, class RandomAccessIterator>
  bool is_heap(ExecutionPolicy &&exec, 
               RandomAccessIterator first, RandomAccessIterator last)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.is_heap(first, last);
  }

  template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
  bool is_heap(ExecutionPolicy &&exec, 
               RandomAccessIterator first, RandomAccessIterator last,
               Compare comp)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.is_heap(first, last, comp);
  }

  template<class ExecutionPolicy, class RandomAccessIterator>
  RandomAccessIterator is_heap_until(ExecutionPolicy &&exec, 
                                     RandomAccessIterator first, RandomAccessIterator last)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.is_heap_until(first, last);
  }

  template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
  RandomAccessIterator is_heap_until(ExecutionPolicy &&exec, 
                                     RandomAccessIterator first, RandomAccessIterator last,
                                     Compare comp)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.is_heap_until(first, last, comp);
  }

  template<class ExecutionPolicy,
           class RandomAccessIterator>
    void nth_element(ExecutionPolicy &&exec,
                     RandomAccessIterator first, RandomAccessIterator nth,
                     RandomAccessIterator last)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    exec.nth_element(first, nth, last);
  }
  template<class ExecutionPolicy,
           class RandomAccessIterator, class Compare>
    void nth_element(ExecutionPolicy &&exec,
                     RandomAccessIterator first, RandomAccessIterator nth,
                     RandomAccessIterator last, Compare comp)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    exec.nth_element(first, nth, last, comp);
  }

  // merge:
  template<class ExecutionPolicy,
           class InputIterator1, class InputIterator2,
           class OutputIterator>
    OutputIterator
      merge(ExecutionPolicy &&exec,
            InputIterator1 first1, InputIterator1 last1,
            InputIterator2 first2, InputIterator2 last2,
            OutputIterator result)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.merge(first1, last1, first2, last2, result);
  }
  template<class ExecutionPolicy,
           class InputIterator1, class InputIterator2,
           class OutputIterator, class Compare>
    OutputIterator
      merge(ExecutionPolicy &&exec,
            InputIterator1 first1, InputIterator1 last1,
            InputIterator2 first2, InputIterator2 last2,
            OutputIterator result, Compare comp)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.merge(first1, last1, first2, last2, result, comp);
  }

  template<class ExecutionPolicy,
           class BidirectionalIterator>
    void inplace_merge(ExecutionPolicy &&exec,
                       BidirectionalIterator first,
                       BidirectionalIterator middle,
                       BidirectionalIterator last)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    exec.inplace_merge(first, middle, last);
  }
  template<class ExecutionPolicy,
           class BidirectionalIterator,
           class Compare>
    void inplace_merge(ExecutionPolicy &&exec,
                       BidirectionalIterator first,
                       BidirectionalIterator middle,
                       BidirectionalIterator last, Compare comp)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    exec.inplace_merge(first, middle, last, comp);
  }

  // set operations:
  template<class ExecutionPolicy,
           class InputIterator1, class InputIterator2>
    bool includes(ExecutionPolicy &&exec,
                  InputIterator1 first1, InputIterator1 last1,
                  InputIterator2 first2, InputIterator2 last2)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.includes(first1, last1, first2, last2);
  }
  template<class ExecutionPolicy,
           class InputIterator1, class InputIterator2, class Compare>
    bool includes(ExecutionPolicy &&exec,
                  InputIterator1 first1, InputIterator1 last1,
                  InputIterator2 first2, InputIterator2 last2,
                  Compare comp)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.includes(first1, last1, first2, last2, comp);
  }

  template<class ExecutionPolicy,
           class InputIterator1, class InputIterator2,
           class OutputIterator>
    OutputIterator
      set_union(ExecutionPolicy &&exec,
                InputIterator1 first1, InputIterator1 last1,
                InputIterator2 first2, InputIterator2 last2,
                OutputIterator result)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.set_union(first1, last1, first2, last2, result);
  }
  template<class ExecutionPolicy,
           class InputIterator1, class InputIterator2,
           class OutputIterator, class Compare>
    OutputIterator
      set_union(ExecutionPolicy &&exec,
                InputIterator1 first1, InputIterator1 last1,
                InputIterator2 first2, InputIterator2 last2,
                OutputIterator result, Compare comp)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.set_union(first1, last1, first2, last2, result, comp);
  }

  template<class ExecutionPolicy,
           class InputIterator1, class InputIterator2,
           class OutputIterator>
    OutputIterator
      set_intersection(ExecutionPolicy &&exec,
                       InputIterator1 first1, InputIterator1 last1,
                       InputIterator2 first2, InputIterator2 last2,
                       OutputIterator result)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.set_intersection(first1, last1, first2, last2, result);
  }
  template<class ExecutionPolicy,
           class InputIterator1, class InputIterator2,
           class OutputIterator, class Compare>
    OutputIterator
      set_intersection(ExecutionPolicy &&exec,
                       InputIterator1 first1, InputIterator1 last1,
                       InputIterator2 first2, InputIterator2 last2,
                       OutputIterator result, Compare comp)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.set_intersection(first1, last1, first2, last2, result, comp);
  }

  template<class ExecutionPolicy,
           class InputIterator1, class InputIterator2,
           class OutputIterator>
    OutputIterator
      set_difference(ExecutionPolicy &&exec,
                     InputIterator1 first1, InputIterator1 last1,
                     InputIterator2 first2, InputIterator2 last2,
                     OutputIterator result)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.set_difference(first1, last1, first2, last2, result);
  }
  template<class ExecutionPolicy,
           class InputIterator1, class InputIterator2,
           class OutputIterator, class Compare>
    OutputIterator
      set_difference(ExecutionPolicy &&exec,
                     InputIterator1 first1, InputIterator1 last1,
                     InputIterator2 first2, InputIterator2 last2,
                     OutputIterator result, Compare comp)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.set_difference(first1, last1, first2, last2, result, comp);
  }

  template<class ExecutionPolicy,
           class InputIterator1, class InputIterator2,
           class OutputIterator>
    OutputIterator
      set_symmetric_difference(ExecutionPolicy &&exec,
                               InputIterator1 first1, InputIterator1 last1,
                               InputIterator2 first2, InputIterator2 last2,
                               OutputIterator result)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.set_symmetric_difference(first1, last1, first2, last2, result);
  }
  template<class ExecutionPolicy,
           class InputIterator1, class InputIterator2,
           class OutputIterator, class Compare>
    OutputIterator
      set_symmetric_difference(ExecutionPolicy &&exec,
                               InputIterator1 first1, InputIterator1 last1,
                               InputIterator2 first2, InputIterator2 last2,
                               OutputIterator result, Compare comp)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.set_symmetric_difference(first1, last1, first2, last2, result, comp);
  }

  // minimum and maximum:
  template<class ExecutionPolicy,
           class ForwardIterator>
    ForwardIterator min_element(ExecutionPolicy &&exec,
                                ForwardIterator first, ForwardIterator last)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.min_element(first, last);
  }
  template<class ExecutionPolicy,
           class ForwardIterator, class Compare>
    ForwardIterator min_element(ExecutionPolicy &&exec,
                                ForwardIterator first, ForwardIterator last,
                                Compare comp)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.min_element(first, last, comp); 
  }
  template<class ExecutionPolicy,
           class ForwardIterator>
    ForwardIterator max_element(ExecutionPolicy &&exec,
                                ForwardIterator first, ForwardIterator last)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.max_element(first, last);
  }
  template<class ExecutionPolicy,
           class ForwardIterator, class Compare>
    ForwardIterator max_element(ExecutionPolicy &&exec,
                                ForwardIterator first, ForwardIterator last,
                                Compare comp)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.max_element(first, last, comp);
  }
  template<class ExecutionPolicy,
           class ForwardIterator>
    std::pair<ForwardIterator, ForwardIterator>
      minmax_element(ExecutionPolicy &&exec,
                     ForwardIterator first, ForwardIterator last)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.minmax_element(first, last);
  }
  template<class ExecutionPolicy,
           class ForwardIterator, class Compare>
    std::pair<ForwardIterator, ForwardIterator>
      minmax_element(ExecutionPolicy &&exec,
                     ForwardIterator first, ForwardIterator last, Compare comp)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.minmax_element(first, last, comp);
  }

  
  template<class ExecutionPolicy,
           class InputIterator1, class InputIterator2>
    bool
      lexicographical_compare(ExecutionPolicy &&exec,
                              InputIterator1 first1, InputIterator1 last1,
                              InputIterator2 first2, InputIterator2 last2)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.lexicographical_compare(first1, last1, first2, last2);
  }
  
  template<class ExecutionPolicy,
           class InputIterator1, class InputIterator2, class Compare>
    bool
      lexicographical_compare(ExecutionPolicy &&exec,
                              InputIterator1 first1, InputIterator1 last1,
                              InputIterator2 first2, InputIterator2 last2,
                              Compare comp)
  {
    static_assert(experimental::parallel::is_execution_policy_v<ExecutionPolicy>,
                  "exec is not a valid execution policy");

    return exec.lexicographical_compare(first1, last1, first2, last2, comp);
  }
} // namespace v1
} // namespace parallel
} // namespace experimental
} // namespace std

#endif
